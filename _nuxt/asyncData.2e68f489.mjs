import{w as O}from"./utils.41cc6a8b.mjs";import{l as b,m as k,p as _,r as g,w as A,q as z,u as B}from"./entry.04926ed9.mjs";const M=()=>null;function I(...o){var p,y,h,m,v,w,D;const f=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(f);let[t,l,e={}]=o;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(p=e.server)!=null?p:!0,e.default=(y=e.default)!=null?y:M,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(m=(h=e.lazy)!=null?h:e.defer)!=null?m:!1,e.initialCache=(v=e.initialCache)!=null?v:!0;const a=b(),i=z();if(i&&!i._nuxtOnBeforeMountCbs){const s=i._nuxtOnBeforeMountCbs=[];i&&(k(()=>{s.forEach(n=>{n()}),s.splice(0,s.length)}),_(()=>s.splice(0,s.length)))}const u=()=>e.initialCache&&a.payload.data[t]!==void 0,r={data:O((w=a.payload.data[t])!=null?w:e.default()),pending:g(!u()),error:g((D=a.payload._errors[t])!=null?D:null)};r.refresh=(s={})=>a._asyncDataPromises[t]?a._asyncDataPromises[t]:s._initial&&u()?a.payload.data[t]:(r.pending.value=!0,a._asyncDataPromises[t]=new Promise((n,C)=>{try{n(l(a))}catch(P){C(P)}}).then(n=>{e.transform&&(n=e.transform(n)),e.pick&&(n=R(n,e.pick)),r.data.value=n,r.error.value=null}).catch(n=>{r.error.value=n,r.data.value=B(e.default())}).finally(()=>{r.pending.value=!1,a.payload.data[t]=r.data.value,r.error.value&&(a.payload._errors[t]=!0),delete a._asyncDataPromises[t]}),a._asyncDataPromises[t]);const c=()=>r.refresh({_initial:!0}),x=e.server!==!1&&a.payload.serverRendered;{x&&a.isHydrating&&t in a.payload.data?r.pending.value=!1:i&&a.payload.serverRendered&&(a.isHydrating||e.lazy)?i._nuxtOnBeforeMountCbs.push(c):c(),e.watch&&A(e.watch,()=>r.refresh());const s=a.hook("app:data:refresh",n=>{if(!n||n.includes(t))return r.refresh()});i&&_(s)}const d=Promise.resolve(a._asyncDataPromises[t]).then(()=>r);return Object.assign(d,r),d}function j(o){const f=o?Array.isArray(o)?o:[o]:void 0;return b().callHook("app:data:refresh",f)}function R(o,f){const t={};for(const l of f)t[l]=o[l];return t}export{j as r,I as u};
